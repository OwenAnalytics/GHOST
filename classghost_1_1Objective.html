<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GHOST: ghost::Objective Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Objective.html">Objective</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classghost_1_1Objective-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Objective Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class encodes objective functions of your COP, as well as the special class <a class="el" href="classghost_1_1NullObjective.html" title="NullObjective is used when no objective functions have been given to the solver (ie, for pure satisfaction runs). ">NullObjective</a> for CSP.  
 <a href="classghost_1_1Objective.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="objective_8hpp_source.html">objective.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__inherit__graph.png" border="0" usemap="#ghost_1_1Objective_inherit__map" alt="Inheritance graph"/></div>
<map name="ghost_1_1Objective_inherit__map" id="ghost_1_1Objective_inherit__map">
<area shape="rect" id="node2" href="classghost_1_1NullObjective.html" title="NullObjective is used when no objective functions have been given to the solver (ie, for pure satisfaction runs). " alt="" coords="31,409,171,487"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__coll__graph.png" border="0" usemap="#ghost_1_1Objective_coll__map" alt="Collaboration graph"/></div>
<map name="ghost_1_1Objective_coll__map" id="ghost_1_1Objective_coll__map">
<area shape="rect" id="node2" href="classghost_1_1Random.html" title="Use this class to generate pseudo&#45;random numbers following a near&#45;uniform distribution. " alt="" coords="21,5,181,141"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30a595b146555401e98f51b5a1ef5bfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a30a595b146555401e98f51b5a1ef5bfb">Objective</a> (const string &amp;<a class="el" href="classghost_1_1Objective.html#af5bf0605c193884ad7f53593dabe8b85">name</a>)</td></tr>
<tr class="memdesc:a30a595b146555401e98f51b5a1ef5bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique constructor.  <a href="#a30a595b146555401e98f51b5a1ef5bfb">More...</a><br /></td></tr>
<tr class="separator:a30a595b146555401e98f51b5a1ef5bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2305f59de130a75785a1dc9269d7ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">Objective</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=default</td></tr>
<tr class="memdesc:a7e2305f59de130a75785a1dc9269d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <a href="#a7e2305f59de130a75785a1dc9269d7ae">More...</a><br /></td></tr>
<tr class="separator:a7e2305f59de130a75785a1dc9269d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">Objective</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <a href="#ae9d567c78a9df7aeae4f8bea71e54b56">More...</a><br /></td></tr>
<tr class="separator:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaedfb85e62325aaa1ce766e60c93d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">operator=</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=delete</td></tr>
<tr class="memdesc:adaedfb85e62325aaa1ce766e60c93d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <a href="#adaedfb85e62325aaa1ce766e60c93d77">More...</a><br /></td></tr>
<tr class="separator:adaedfb85e62325aaa1ce766e60c93d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">operator=</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <a href="#a5682a026b25d9ca93cacf3d19f5ef0ec">More...</a><br /></td></tr>
<tr class="separator:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b288b785eb9abd31389adffe0e82716"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">~Objective</a> ()=default</td></tr>
<tr class="separator:a9b288b785eb9abd31389adffe0e82716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf174d82bf2a9f9b0ad72f11a279799e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adf174d82bf2a9f9b0ad72f11a279799e">cost</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables) const </td></tr>
<tr class="memdesc:adf174d82bf2a9f9b0ad72f11a279799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling v_cost.  <a href="#adf174d82bf2a9f9b0ad72f11a279799e">More...</a><br /></td></tr>
<tr class="separator:adf174d82bf2a9f9b0ad72f11a279799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da0d81b3f4c83cb6f4b2a33e2822d2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a0da0d81b3f4c83cb6f4b2a33e2822d2f">heuristic_value</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, <a class="el" href="classghost_1_1Variable.html">Variable</a> *var, const vector&lt; int &gt; &amp;possible_values) const </td></tr>
<tr class="memdesc:a0da0d81b3f4c83cb6f4b2a33e2822d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_heuristic_value.  <a href="#a0da0d81b3f4c83cb6f4b2a33e2822d2f">More...</a><br /></td></tr>
<tr class="separator:a0da0d81b3f4c83cb6f4b2a33e2822d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21823582664ad75307439adf3cb1f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af21823582664ad75307439adf3cb1f5e">heuristic_value</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; bad_variables) const </td></tr>
<tr class="memdesc:af21823582664ad75307439adf3cb1f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_heuristic_value.  <a href="#af21823582664ad75307439adf3cb1f5e">More...</a><br /></td></tr>
<tr class="separator:af21823582664ad75307439adf3cb1f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ae98042b3ba81a9bd501d542820b66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af7ae98042b3ba81a9bd501d542820b66">postprocess_satisfaction</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const </td></tr>
<tr class="memdesc:af7ae98042b3ba81a9bd501d542820b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_postprocess_satisfaction.  <a href="#af7ae98042b3ba81a9bd501d542820b66">More...</a><br /></td></tr>
<tr class="separator:af7ae98042b3ba81a9bd501d542820b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e4461791d365f18078d3fc7d23a67d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a93e4461791d365f18078d3fc7d23a67d">postprocess_optimization</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const </td></tr>
<tr class="memdesc:a93e4461791d365f18078d3fc7d23a67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_postprocess_optimization.  <a href="#a93e4461791d365f18078d3fc7d23a67d">More...</a><br /></td></tr>
<tr class="separator:a93e4461791d365f18078d3fc7d23a67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e8ef04bf5cfc74d931742a578b282e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a27e8ef04bf5cfc74d931742a578b282e">get_name</a> () const </td></tr>
<tr class="memdesc:a27e8ef04bf5cfc74d931742a578b282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline accessor to get the name of the objective object.  <a href="#a27e8ef04bf5cfc74d931742a578b282e">More...</a><br /></td></tr>
<tr class="separator:a27e8ef04bf5cfc74d931742a578b282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5f6db473f497e84cf15d0a638be21d31"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5f6db473f497e84cf15d0a638be21d31">required_cost</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables) const =0</td></tr>
<tr class="memdesc:a5f6db473f497e84cf15d0a638be21d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function to compute the value of the objective function on the current configuration.  <a href="#a5f6db473f497e84cf15d0a638be21d31">More...</a><br /></td></tr>
<tr class="separator:a5f6db473f497e84cf15d0a638be21d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0f733d219978343b9532d1e8168510"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a4e0f733d219978343b9532d1e8168510">expert_heuristic_value</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, <a class="el" href="classghost_1_1Variable.html">Variable</a> *var, const vector&lt; int &gt; &amp;possible_values) const </td></tr>
<tr class="memdesc:a4e0f733d219978343b9532d1e8168510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to apply the value heuristic used by the solver for non permutation problems.  <a href="#a4e0f733d219978343b9532d1e8168510">More...</a><br /></td></tr>
<tr class="separator:a4e0f733d219978343b9532d1e8168510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e649c3e9a6e71fbdac3194120728bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a26e649c3e9a6e71fbdac3194120728bb">expert_heuristic_value</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; bad_variables) const </td></tr>
<tr class="memdesc:a26e649c3e9a6e71fbdac3194120728bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to apply the value heuristic used by the solver for permutation problems.  <a href="#a26e649c3e9a6e71fbdac3194120728bb">More...</a><br /></td></tr>
<tr class="separator:a26e649c3e9a6e71fbdac3194120728bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d84f1a341b9366a66b3cb52568ded33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a0d84f1a341b9366a66b3cb52568ded33">expert_postprocess_satisfaction</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const </td></tr>
<tr class="memdesc:a0d84f1a341b9366a66b3cb52568ded33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to perform satisfaction post-processing.  <a href="#a0d84f1a341b9366a66b3cb52568ded33">More...</a><br /></td></tr>
<tr class="separator:a0d84f1a341b9366a66b3cb52568ded33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb30d2973d51e6c788533f7a4b1c493"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5fb30d2973d51e6c788533f7a4b1c493">expert_postprocess_optimization</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const </td></tr>
<tr class="memdesc:a5fb30d2973d51e6c788533f7a4b1c493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to perform optimization post-processing.  <a href="#a5fb30d2973d51e6c788533f7a4b1c493">More...</a><br /></td></tr>
<tr class="separator:a5fb30d2973d51e6c788533f7a4b1c493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a86081d1ebbab1fe6f781841d9ac8d546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Random.html">Random</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a86081d1ebbab1fe6f781841d9ac8d546">random</a></td></tr>
<tr class="memdesc:a86081d1ebbab1fe6f781841d9ac8d546"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classghost_1_1Random.html" title="Use this class to generate pseudo-random numbers following a near-uniform distribution. ">Random</a> generator used by the function heuristicValue.  <a href="#a86081d1ebbab1fe6f781841d9ac8d546">More...</a><br /></td></tr>
<tr class="separator:a86081d1ebbab1fe6f781841d9ac8d546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf0605c193884ad7f53593dabe8b85"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af5bf0605c193884ad7f53593dabe8b85">name</a></td></tr>
<tr class="memdesc:af5bf0605c193884ad7f53593dabe8b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for the name of the objective object.  <a href="#af5bf0605c193884ad7f53593dabe8b85">More...</a><br /></td></tr>
<tr class="separator:af5bf0605c193884ad7f53593dabe8b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class encodes objective functions of your COP, as well as the special class <a class="el" href="classghost_1_1NullObjective.html" title="NullObjective is used when no objective functions have been given to the solver (ie, for pure satisfaction runs). ">NullObjective</a> for CSP. </p>
<p>In GHOST, many different objective objects can be instanciate.</p>
<p>You cannot directly use this class <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP, as well as the special class NullObjective for CS...">Objective</a> to encode your objective functions since this is an abstract class. Yhus, you must write your own objective class inheriting from <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP, as well as the special class NullObjective for CS...">ghost::Objective</a>. You can write different objective classes to model your problem, and switch from an objective to another between two <a class="el" href="classghost_1_1Solver.html#ab2f3b79560cefbe8299583a40edad40e" title="Solver&#39;s main function, to solve the given CSP/COP. ">Solver::solve</a> calls.</p>
<p>In this class, each virtual function follows the Non-Virtual Interface Idiom (see <a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a>). The only pure virtual function is required_cost. All other virtual functions have a default behavior implemented and are prefixed by 'expert_'. It is highly recommended to override these functions only if you know what you are doing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html" title="This class encodes variables of your CSP/COP. You cannot inherits your own class from Variable...">Variable</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a30a595b146555401e98f51b5a1ef5bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A const reference to a string to give the <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP, as well as the special class NullObjective for CS...">Objective</a> object a specific name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e2305f59de130a75785a1dc9269d7ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy contructor. </p>

</div>
</div>
<a class="anchor" id="ae9d567c78a9df7aeae4f8bea71e54b56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move contructor. </p>

</div>
</div>
<a class="anchor" id="a9b288b785eb9abd31389adffe0e82716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ghost::Objective::~Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adf174d82bf2a9f9b0ad72f11a279799e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::Objective::cost </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling v_cost. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a5f6db473f497e84cf15d0a638be21d31" title="Pure virtual function to compute the value of the objective function on the current configuration...">required_cost</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0f733d219978343b9532d1e8168510"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to apply the value heuristic used by the solver for non permutation problems. </p>
<p>While deadling with non permutation problems, the solver calls this function to apply an eventual user-defined heuristic to choose a new domain value for a variable selected by the solver.</p>
<p>The default implementation outputs the value leading to the lowest objective cost. If two or more values lead to configurations with the same lowest cost, one of them is randomly returned.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A pointer to the vector containing all variables. </td></tr>
    <tr><td class="paramname">var</td><td>A pointer to the variable to change. </td></tr>
    <tr><td class="paramname">possible_values</td><td>A const reference to the vector of possible values of var. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected value according to the heuristic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a0da0d81b3f4c83cb6f4b2a33e2822d2f" title="Inline function following the NVI idiom. Calling expert_heuristic_value. ">heuristic_value</a>, <a class="el" href="classghost_1_1Random.html" title="Use this class to generate pseudo-random numbers following a near-uniform distribution. ">Random</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26e649c3e9a6e71fbdac3194120728bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classghost_1_1Variable.html">Variable</a>* ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt;&#160;</td>
          <td class="paramname"><em>bad_variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to apply the value heuristic used by the solver for permutation problems. </p>
<p>While deadling with permutation problems, the solver calls this function to apply an eventual user-defined heuristic to choose a variable to swap the value with.</p>
<p>By default, it returns a random variable among the vector in input.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bad_variables</td><td>The vector of candidate variables the solver may swap the value with another variable it had chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected variable to swap with, according to the heuristic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a0da0d81b3f4c83cb6f4b2a33e2822d2f" title="Inline function following the NVI idiom. Calling expert_heuristic_value. ">heuristic_value</a>, <a class="el" href="classghost_1_1Random.html" title="Use this class to generate pseudo-random numbers following a near-uniform distribution. ">Random</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5fb30d2973d51e6c788533f7a4b1c493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_optimization </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to perform optimization post-processing. </p>
<p>This function is called by the solver after all optimization runs to apply human-knowledge optimization, allowing to improve the optimization cost.</p>
<p>It does nothing By default. You need to override it to have an optimization postprocess.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The computation spantime of this function is not taken into account by timeouts given to the solver. If you override this function, be sure its computation time is neglictable compare to the optimization timeout you give to <a class="el" href="classghost_1_1Solver.html#ab2f3b79560cefbe8299583a40edad40e" title="Solver&#39;s main function, to solve the given CSP/COP. ">Solver::solve</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A pointer to the vector of variables of the CSP/COP. </td></tr>
    <tr><td class="paramname">bestCost</td><td>A reference the double representing the best optimization cost found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>A reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a93e4461791d365f18078d3fc7d23a67d" title="Inline function following the NVI idiom. Calling expert_postprocess_optimization. ...">postprocess_optimization</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d84f1a341b9366a66b3cb52568ded33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_satisfaction </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to perform satisfaction post-processing. </p>
<p>This function is called by the solver after a satisfaction run, if the solver was able to find a solution, to apply human-knowledge in order to "clean-up" the proposed solution.</p>
<p>It does nothing By default. You need to override it to have a satisfaction postprocess.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A pointer to the vector of variables of the CSP/COP. </td></tr>
    <tr><td class="paramname">bestCost</td><td>A reference the double representing the best satisfaction cost found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>A reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#af7ae98042b3ba81a9bd501d542820b66" title="Inline function following the NVI idiom. Calling expert_postprocess_satisfaction. ...">postprocess_satisfaction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a27e8ef04bf5cfc74d931742a578b282e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string ghost::Objective::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline accessor to get the name of the objective object. </p>

</div>
</div>
<a class="anchor" id="a0da0d81b3f4c83cb6f4b2a33e2822d2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ghost::Objective::heuristic_value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_heuristic_value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a4e0f733d219978343b9532d1e8168510" title="Virtual function to apply the value heuristic used by the solver for non permutation problems...">expert_heuristic_value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af21823582664ad75307439adf3cb1f5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Variable.html">Variable</a>* ghost::Objective::heuristic_value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt;&#160;</td>
          <td class="paramname"><em>bad_variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_heuristic_value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a4e0f733d219978343b9532d1e8168510" title="Virtual function to apply the value heuristic used by the solver for non permutation problems...">expert_heuristic_value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adaedfb85e62325aaa1ce766e60c93d77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator disabled. </p>

</div>
</div>
<a class="anchor" id="a5682a026b25d9ca93cacf3d19f5ef0ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator disabled. </p>

</div>
</div>
<a class="anchor" id="a93e4461791d365f18078d3fc7d23a67d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::postprocess_optimization </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_postprocess_optimization. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a5fb30d2973d51e6c788533f7a4b1c493" title="Virtual function to perform optimization post-processing. ">expert_postprocess_optimization</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af7ae98042b3ba81a9bd501d542820b66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::postprocess_satisfaction </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_postprocess_satisfaction. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a0d84f1a341b9366a66b3cb52568ded33" title="Virtual function to perform satisfaction post-processing. ">expert_postprocess_satisfaction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f6db473f497e84cf15d0a638be21d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Objective::required_cost </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function to compute the value of the objective function on the current configuration. </p>
<p>Like <a class="el" href="classghost_1_1Constraint.html#a6ef4cd03a4dc864a8d308e55044c615d" title="Pure virtual function to compute the current cost of the constraint. ">Constraint::required_cost</a>, this function is fundamental: it evalutes the performance of the current values of the variables. GHOST will search for variable values that will minimize the output of this function. If you are modelling a maximization problem, ie, a problem where its natural objective function f(x) = z is to try to find the highest possible z, you can simplify write this function such that it outputs -z. Values of variables minimizing -z will also maximize z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A pointer to the vector of variable of the CSP/COP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double in R corresponding to the value of the objective function on the current configuration. Unlike <a class="el" href="classghost_1_1Constraint.html#a6ef4cd03a4dc864a8d308e55044c615d" title="Pure virtual function to compute the current cost of the constraint. ">Constraint::required_cost</a>, this output may be negative. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#adf174d82bf2a9f9b0ad72f11a279799e" title="Inline function following the NVI idiom. Calling v_cost. ">cost</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af5bf0605c193884ad7f53593dabe8b85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string ghost::Objective::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String for the name of the objective object. </p>

</div>
</div>
<a class="anchor" id="a86081d1ebbab1fe6f781841d9ac8d546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Random.html">Random</a> ghost::Objective::random</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classghost_1_1Random.html" title="Use this class to generate pseudo-random numbers following a near-uniform distribution. ">Random</a> generator used by the function heuristicValue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="objective_8hpp_source.html">objective.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 11 2018 17:54:24 for GHOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
