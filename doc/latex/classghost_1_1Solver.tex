\hypertarget{classghost_1_1Solver}{}\section{ghost\+:\+:Solver Class Reference}
\label{classghost_1_1Solver}\index{ghost\+::\+Solver@{ghost\+::\+Solver}}


\hyperlink{classghost_1_1Solver}{Solver} is the class coding the solver itself.  




{\ttfamily \#include $<$solver.\+hpp$>$}



Collaboration diagram for ghost\+:\+:Solver\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=154pt]{classghost_1_1Solver__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classghost_1_1Solver_aee56a03908003c1a1120466e72ac3799}{Solver} (const vector$<$ \hyperlink{classghost_1_1Variable}{Variable} $>$ \&vec\+Variables, const vector$<$ shared\+\_\+ptr$<$ \hyperlink{classghost_1_1Constraint}{Constraint} $>$$>$ \&vec\+Constraints, shared\+\_\+ptr$<$ \hyperlink{classghost_1_1Objective}{Objective} $>$ objective, bool permutation\+Problem=false)
\begin{DoxyCompactList}\small\item\em \hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s regular constructor. \end{DoxyCompactList}\item 
\hyperlink{classghost_1_1Solver_ade9340e94794a2ed0058957443be34e0}{Solver} (const vector$<$ \hyperlink{classghost_1_1Variable}{Variable} $>$ \&vec\+Variables, const vector$<$ shared\+\_\+ptr$<$ \hyperlink{classghost_1_1Constraint}{Constraint} $>$$>$ \&vec\+Constraints, bool permutation\+Problem=false)
\begin{DoxyCompactList}\small\item\em Second \hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s constructor, without \hyperlink{classghost_1_1Objective}{Objective}. \end{DoxyCompactList}\item 
bool \hyperlink{classghost_1_1Solver_acc72c5a651e888858c10dfe300d96fa8}{solve} (double \&final\+Cost, vector$<$ int $>$ \&final\+Solution, double sat\+\_\+timeout, double opt\+\_\+timeout=0.)
\begin{DoxyCompactList}\small\item\em \hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s main function, to solve the given C\+S\+P/\+C\+OP. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{classghost_1_1Solver}{Solver} is the class coding the solver itself. 

To solve a problem instance, you must instanciate a \hyperlink{classghost_1_1Solver}{Solver} object, then run \hyperlink{classghost_1_1Solver_acc72c5a651e888858c10dfe300d96fa8}{Solver\+::solve}.

\hyperlink{classghost_1_1Solver}{Solver} constructors need a vector of \hyperlink{classghost_1_1Variable}{Variable}, a vector of shared pointers on \hyperlink{classghost_1_1Constraint}{Constraint} objects, an optional shared pointer on an \hyperlink{classghost_1_1Objective}{Objective} object (the solver will create a special empty \hyperlink{classghost_1_1Objective}{Objective} object is none is given), and finally an optionnal boolean to indicate if the problem has been modeled as a permutation problem (false by default).

A permutation problem is a problem where all variables start with different values, and only swapping values is allowed. This is typically the case for scheduling problems, for instance\+: you want to do A first, then B second, C third, and so on. The solution of the problem must assign a unique value for each variable. Try as much as possible to model your problems as permutation problems, since it should greatly speed-\/up the search of solutions.

\begin{DoxySeeAlso}{See also}
\hyperlink{classghost_1_1Variable}{Variable}, \hyperlink{classghost_1_1Constraint}{Constraint}, \hyperlink{classghost_1_1Objective}{Objective} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\index{ghost\+::\+Solver@{ghost\+::\+Solver}!Solver@{Solver}}
\index{Solver@{Solver}!ghost\+::\+Solver@{ghost\+::\+Solver}}
\subsubsection[{\texorpdfstring{Solver(const vector$<$ Variable $>$ \&vec\+Variables, const vector$<$ shared\+\_\+ptr$<$ Constraint $>$$>$ \&vec\+Constraints, shared\+\_\+ptr$<$ Objective $>$ objective, bool permutation\+Problem=false)}{Solver(const vector< Variable > &vecVariables, const vector< shared_ptr< Constraint >> &vecConstraints, shared_ptr< Objective > objective, bool permutationProblem=false)}}]{\setlength{\rightskip}{0pt plus 5cm}ghost\+::\+Solver\+::\+Solver (
\begin{DoxyParamCaption}
\item[{const vector$<$ {\bf Variable} $>$ \&}]{vec\+Variables, }
\item[{const vector$<$ shared\+\_\+ptr$<$ {\bf Constraint} $>$$>$ \&}]{vec\+Constraints, }
\item[{shared\+\_\+ptr$<$ {\bf Objective} $>$}]{objective, }
\item[{bool}]{permutation\+Problem = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{classghost_1_1Solver_aee56a03908003c1a1120466e72ac3799}{}\label{classghost_1_1Solver_aee56a03908003c1a1120466e72ac3799}


\hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s regular constructor. 


\begin{DoxyParams}{Parameters}
{\em vec\+Variables} & A const reference to the vector of Variables. \\
\hline
{\em vec\+Constraints} & A const reference to the vector of Constraints. \\
\hline
{\em obj} & A shared pointer to the \hyperlink{classghost_1_1Objective}{Objective}. \\
\hline
{\em permutation\+Problem} & A boolean indicating if we work on a permutation problem. False by default. \\
\hline
\end{DoxyParams}
\index{ghost\+::\+Solver@{ghost\+::\+Solver}!Solver@{Solver}}
\index{Solver@{Solver}!ghost\+::\+Solver@{ghost\+::\+Solver}}
\subsubsection[{\texorpdfstring{Solver(const vector$<$ Variable $>$ \&vec\+Variables, const vector$<$ shared\+\_\+ptr$<$ Constraint $>$$>$ \&vec\+Constraints, bool permutation\+Problem=false)}{Solver(const vector< Variable > &vecVariables, const vector< shared_ptr< Constraint >> &vecConstraints, bool permutationProblem=false)}}]{\setlength{\rightskip}{0pt plus 5cm}ghost\+::\+Solver\+::\+Solver (
\begin{DoxyParamCaption}
\item[{const vector$<$ {\bf Variable} $>$ \&}]{vec\+Variables, }
\item[{const vector$<$ shared\+\_\+ptr$<$ {\bf Constraint} $>$$>$ \&}]{vec\+Constraints, }
\item[{bool}]{permutation\+Problem = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{classghost_1_1Solver_ade9340e94794a2ed0058957443be34e0}{}\label{classghost_1_1Solver_ade9340e94794a2ed0058957443be34e0}


Second \hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s constructor, without \hyperlink{classghost_1_1Objective}{Objective}. 


\begin{DoxyParams}{Parameters}
{\em vec\+Variables} & A const reference to the vector of Variables. \\
\hline
{\em vec\+Constraints} & A const reference to the vector of Constraints. \\
\hline
{\em permutation\+Problem} & A boolean indicating if we work on a permutation problem. False by default. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{ghost\+::\+Solver@{ghost\+::\+Solver}!solve@{solve}}
\index{solve@{solve}!ghost\+::\+Solver@{ghost\+::\+Solver}}
\subsubsection[{\texorpdfstring{solve(double \&final\+Cost, vector$<$ int $>$ \&final\+Solution, double sat\+\_\+timeout, double opt\+\_\+timeout=0.)}{solve(double &finalCost, vector< int > &finalSolution, double sat_timeout, double opt_timeout=0.)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ghost\+::\+Solver\+::solve (
\begin{DoxyParamCaption}
\item[{double \&}]{final\+Cost, }
\item[{vector$<$ int $>$ \&}]{final\+Solution, }
\item[{double}]{sat\+\_\+timeout, }
\item[{double}]{opt\+\_\+timeout = {\ttfamily 0.}}
\end{DoxyParamCaption}
)}\hypertarget{classghost_1_1Solver_acc72c5a651e888858c10dfe300d96fa8}{}\label{classghost_1_1Solver_acc72c5a651e888858c10dfe300d96fa8}


\hyperlink{classghost_1_1Solver}{Solver}\textquotesingle{}s main function, to solve the given C\+S\+P/\+C\+OP. 

This function is the heart of G\+H\+O\+ST\textquotesingle{}s solver\+: it will try to find a solution within a limit time. If it finds wuch a solution, the function outputs the value true.~\newline
Here how it works\+: if at least one solution is found, at the end of the computation, it will write in the two first parameters final\+Cost and final\+Solution the cost of the best solution found and the value of each variable.~\newline
For a satisfaction problem (without any objective functions), the cost of a solution is the sum of the cost of each problem constraint (computated by \hyperlink{classghost_1_1Constraint_a6ef4cd03a4dc864a8d308e55044c615d}{Constraint\+::required\+\_\+cost}). For an optimization problem, the cost is the value outputed by \hyperlink{classghost_1_1Objective_aae6630f4fca9012278a0bf1ca1503cd0}{Objective\+::required\+\_\+cost}.~\newline
For both, the lower value the better\+: A satisfaction cost of 0 means we have a solution to a satisfaction problem (ie, all constraints are satisfied). An optimization cost should be as low as possible\+: G\+H\+O\+ST is handling minimization problems only. If you have a maximization problem (you are looking to the highest possible value of your objective function), look at the \hyperlink{classghost_1_1Objective}{Objective} documentation to see how to easily convert your problem into a minimization problem.

The two last parameters sat\+\_\+timeout and opt\+\_\+timeout are fundamental\+: sat\+\_\+timeout is mandatory, opt\+\_\+timeout is optional\+: if not given, its value will be fixed to sat\+\_\+timeout $\ast$ 10.~\newline
sat\+\_\+timeout is the timeout in milliseconds you give to G\+H\+O\+ST to find a solution to the problem, ie, finding a value for each variable such that each constraint of the problem is satisfied. For a satisfaction problem, this is the timeout within G\+H\+O\+ST must output a solution.~\newline
opt\+\_\+timeout is only useful for optimization problems. Once G\+H\+O\+ST finds a solution within sat\+\_\+timeout, it saves it and try to find other solutions leading to better (ie, smaller) values of the objective function. Then it restart a fresh satisfaction search, with again sat\+\_\+timeout as a timeout to find a solution. It will repeat this operation until opt\+\_\+timeout is reached.

Thus for instance, if you set sat\+\_\+timeout to 20ms and opt\+\_\+timeout to 60ms (or bit more like 61 or 62ms, see why below), you let G\+H\+O\+ST the time to run 3 satisfaction runs within a global runtime of 60ms (or 61, 62ms), like illustrated below.


\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{architecture.png}
\caption{x and y milliseconds correspond respectively to sat\+\_\+timeout and opt\+\_\+timeout}
\end{DoxyImage}
 It is possible it returns no solutions after timeout; in that case \hyperlink{classghost_1_1Solver_acc72c5a651e888858c10dfe300d96fa8}{Solver\+::solve} returns false. If it is often the case, this is a strong evidence the satisfaction timeout is too low, and the solver does not have time to find at least one solution. Thus, this is the only parameter you may have to tweak in G\+H\+O\+ST.

The illustration above shows satisfaction and optimization post-\/processes. The first one is triggered each time the solver found a solution. If the user overloads \hyperlink{classghost_1_1Objective_a5f7af74c8b54cffbff4c42a5bdf1e563}{Objective\+::expert\+\_\+postprocess\+\_\+satisfaction}, he or she must be sure that his or her function runs very quickly, otherwise it may slow down the whole optimization process and may limit the number of solutions found by the solver. Optimization post-\/process runtime is not taken into account within opt\+\_\+timeout, so the real G\+H\+O\+ST runtime for optimization problems will be roughly equals to opt\+\_\+timeout + optimization post-\/process runtime.


\begin{DoxyParams}{Parameters}
{\em final\+Cost} & A reference to the double of the sum of constraints cost for satisfaction problems, or the value of the objective function for optimization problems. For satisfaction problems, a cost of zero means a solution has been found. \\
\hline
{\em final\+Solution} & The configuration of the best solution found, ie, a reference to the vector of assignements of each variable. \\
\hline
{\em sat\+\_\+timeout} & The satisfaction timeout in milliseconds. \\
\hline
{\em opt\+\_\+timeout} & The optimization timeout in milliseconds (optionnal, equals to 10 times sat\+\_\+timeout is not set). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True iff a solution has been found. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{solver_8hpp}{solver.\+hpp}\end{DoxyCompactItemize}
